mod data_vectors;
mod import;

use sqlx::{Pool, Postgres};
use crate::AppError;
use std::path::PathBuf;
use log::info;

pub async fn create_city_tables(pool: &Pool<Postgres>) -> Result<(), AppError> {

    let sql = r#"SET client_min_messages TO WARNING; 
                drop table if exists geo.cities;
                create table geo.cities
                (
                    id                    int primary key
                  , name                  varchar
                  , disamb_type           varchar
                  , disamb_id             int
                  , disamb_code           varchar
                  , disamb_name           varchar
                  , country_id            int
                  , country_code          varchar
                  , country_name          varchar
                  , lat                   float
                  , lng                   float
                  , pop                   int
                );
                
            drop table if exists src.cities;
                create table src.cities
                (
                    id                    int primary key
                  , name                  varchar
                  , disamb_type           varchar
                  , disamb_id             int
                  , disamb_code           varchar
                  , disamb_name           varchar
                  , country_id            int
                  , country_code          varchar
                  , country_name          varchar
                  , lat                   float
                  , lng                   float
                  , pop                   int
                );
                
            drop table if exists src.city_names;
            create table src.city_names
            (
                  id                    int PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY (START WITH 1000001 INCREMENT BY 1) NOT NULL
                , city_id               int
                , city_name             varchar
                , disamb_id             int
                , disamb_name           varchar
                , country_id            int
                , country_name          varchar
                , alt_name              varchar
                , langlist              varchar
            );
            create index city_names_city_id on src.city_names(city_id);
            create index city_names_alt_name on src.city_names(alt_name);"#;

    sqlx::raw_sql(sql).execute(pool)
            .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    Ok(())
}


pub async fn import_data(data_folder: &PathBuf, source_file_name: &str, pool: &Pool<Postgres>) -> Result<(), AppError> {

    import::import_cities_data(data_folder, source_file_name, pool).await?;
    transfer_cities_data(pool).await?;
    update_cities_data(pool).await?;
    update_orphaned_cities_data(pool).await?;
    remove_dup_cities_1(pool).await?;
    remove_dup_cities_2(pool).await?;

    create_city_names(pool).await?;
    add_missing_city_names(pool).await?;
    delete_dup_city_names(pool).await?;

    Ok(())
}


async fn transfer_cities_data(pool: &Pool<Postgres>) -> Result<(), AppError> {

    let sql = r#"insert into src.cities(id, name, disamb_type, disamb_id, disamb_code, disamb_name, 
    country_id, country_code, country_name, lat, lng, pop)
    select id, name, disamb_type, disamb_id, disamb_code, disamb_name, 
    country_id, country_code, country_name, lat, lng, pop
    from geo.cities"#;

    let res = sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    info!("{} city records transferred to geo schema", res.rows_affected());

    Ok(())
}


async fn update_cities_data(pool: &Pool<Postgres>) -> Result<(), AppError> {

    let sql = r#"update src.cities g
                 set country_id = null
                 where country_code = 'none'"#;

    sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    let sql = r#"update src.cities g
                 set country_id = c.id,
                 country_name = c.country_name
                 from src.countries c
                 where g.country_code = c.iso_code"#;

    sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    let sql = r#"update src.cities g
                set disamb_code = null
                where disamb_code = 'none'"#;

    sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    let sql = r#"update src.cities c
                 set disamb_id = a.id,
                 disamb_name = a.name 
                 from geo.adm1s a
                 where c.disamb_code = a.code
                 and c.disamb_type = 'admin1'"#;

    let res = sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    info!("{} city records updated with admin1 details", res.rows_affected());

    let sql = r#"update src.cities c
                 set disamb_id = a.id,
                 disamb_name = a.name 
                 from geo.adm2s a
                 where c.disamb_code = a.code
                 and c.disamb_type = 'admin2'"#;

    let res = sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    info!("{} city records updated with admin2 details", res.rows_affected());

    Ok(())
}


async fn update_orphaned_cities_data(pool: &Pool<Postgres>) -> Result<(), AppError> {

    // As Hong Kong and Macao have been removed from the countries list, their cities
    // need to be re-assigned to China.

    let sql = r#"update src.cities
                set disamb_name = disamb_name||' (HK)',
                country_id = 1814991,
                country_code = 'CN',
                country_name = 'China'
                where country_code = 'HK';

                update src.cities
                set disamb_name = disamb_name||' (Macao)',
                country_id = 1814991,
                country_code = 'CN',
                country_name = 'China'
                where country_code = 'MO';"#;

    sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;
    
    Ok(())
}


async fn remove_dup_cities_1(pool: &Pool<Postgres>) -> Result<(), AppError> {

    // Deals with dup cities in same disamb area and country 
    // In initial method, the city with the greater population is retained

    let sql = r#"SET client_min_messages TO WARNING; 
        drop table if exists src.temp_city_dups;
        create table src.temp_city_dups as
        select  
            name, country_name, disamb_name, count(id), true as to_drop
            from src.cities 
            group by name, disamb_name, country_name
            having count(id) > 1;

        drop table if exists src.temp_city_dup_recs;
        create table src.temp_city_dup_recs as
        select  
            g.*, true as to_drop
            from src.cities g
            inner join src.temp_city_dups d
            on g.name = d.name
            and g.disamb_name = d.disamb_name
            and g.country_name = d.country_name;

        drop table if exists src.temp_max_pop_dups;
        create table src.temp_max_pop_dups as 
        select name, disamb_name, country_name, max(pop) as maxpop
        from src.temp_city_dup_recs
        group by name, disamb_name, country_name;

        update src.temp_city_dup_recs d
        set to_drop = false
        from src.temp_max_pop_dups m
        where d.name = m.name
        and d.disamb_name = m.disamb_name
        and d.country_name = m.country_name
        and d.pop = m.maxpop;"#;

    sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    let sql = r#"delete from src.cities c
        using src.temp_city_dup_recs d
        where c.id = d.id
        and d.to_drop = true;"#;

    let res = sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    let sql = r#"SET client_min_messages TO WARNING; 
        drop table if exists src.temp_city_dup_recs;
        drop table if exists src.temp_max_pop_dups;
        drop table if exists src.temp_city_dups;"#;

    sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    info!("{} duplicated city records (name, area, country) with lower populations deleted", 
        res.rows_affected());
    
    Ok(())
}


async fn remove_dup_cities_2(pool: &Pool<Postgres>) -> Result<(), AppError> {

    // Deals with remaining dup cities in same disamb area and country 
    // In second method, cities have the same population. The one with the 
    // minimum id is removed.

    let sql = r#"SET client_min_messages TO WARNING; 
            drop table if exists src.temp_city_dups;
            create table src.temp_city_dups as
            select  
                name, country_name, disamb_name, count(id), true as to_drop
                from src.cities 
                group by name, disamb_name, country_name
                having count(id) > 1;

            drop table if exists src.temp_city_dup_recs;
            create table src.temp_city_dup_recs as
            select  
                g.*, true as to_drop
                from src.cities g
                inner join src.temp_city_dups d
                on g.name = d.name
                and g.disamb_name = d.disamb_name
                and g.country_name = d.country_name;

            drop table if exists src.temp_min_id_dups;
            create table src.temp_min_id_dups as 
            select name, disamb_name, country_name, min(id) as minid
            from src.temp_city_dup_recs
            group by name, disamb_name, country_name;"#;

    sqlx::raw_sql(sql).execute(pool)
            .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    let sql = r#"delete from src.cities c
            using src.temp_min_id_dups d
            where c.id = d.minid"#;

    let res = sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    let sql = r#"SET client_min_messages TO WARNING; 
            drop table if exists src.temp_city_dup_recs;
            drop table if exists src.temp_min_id_dups;
            drop table if exists src.temp_city_dups;"#;

    sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    info!("{} duplicated city records (name, area, country, population) with lower id deleted", 
        res.rows_affected());

    Ok(())
}


async fn create_city_names(pool: &Pool<Postgres>) -> Result<(), AppError> {
    
    let sql = r#"insert into src.city_names (city_id, city_name, disamb_id, 
         disamb_name, country_id, country_name, alt_name, langlist)
         select c.id, c.name, c.disamb_id, c.disamb_name, c.country_id, 
         c.country_name, a.alt_name, a.langs
         from src.cities c 
         inner join geo.alt_names a
         on c.id = a.id;"#;

    let res = sqlx::raw_sql(sql).execute(pool)
    .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    info!("{} city name records created", res.rows_affected());

    Ok(())
}


async fn add_missing_city_names(pool: &Pool<Postgres>) -> Result<(), AppError> {
    
    // It appears that in the geonames data about 4600 cities (out of a total of 143,000+)
    // do not have an alt_name matching the geoname city_name - the folowing ensures that all
    // names are in the city_names table

    let sql = r#"SET client_min_messages TO WARNING; 
         drop table if exists src.temp_city_match;

         create table src.temp_city_match as 
         select *
         from src.city_names
         where city_name = alt_name;"#;

    sqlx::raw_sql(sql).execute(pool)
         .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;
     
    let sql = r#"insert into src.city_names
         (city_id, city_name, disamb_id, disamb_name, 
         country_id, country_name, alt_name)
         select distinct n.city_id, n.city_name, 
         n.disamb_id, n.disamb_name, n.country_id, 
         n.country_name, n.city_name as alt_name
         from src.city_names n
         left join src.temp_city_match m
         on n.city_id = m.city_id
         where m.id is null;
         
         drop table src.temp_city_match;"#;

    let res = sqlx::raw_sql(sql).execute(pool)
    .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;

    info!("{} missing city default names added to the city_names table", res.rows_affected());

    Ok(())
}


async fn delete_dup_city_names(pool: &Pool<Postgres>) -> Result<(), AppError> {
 
    // Should be no excact duplicates - country, disamb area, alt_name
    // but there still are (genuine) dups of the same alt name inthe country
    // This eliminates that proportion of duplicated alt_names which are not the 
    // same as the official 'main; name (about a third of them).

    let sql = r#"SET client_min_messages TO WARNING; 
            drop table if exists src.temp_dup_city_names;

            create table src.temp_dup_city_names
            as select  
            country_name, alt_name, count(id)
            from src.city_names 
            group by country_name, alt_name
            having count(id) > 1"#;

    sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;    

    let sql = r#"delete from src.city_names n
            using src.temp_dup_city_names d
            where d.country_name = n.country_name
            and d.alt_name = n.alt_name
            and d.alt_name <> n.city_name;
                        
            drop table if exists src.temp_dup_city_names;
            SET client_min_messages TO WARNING; "#;

    let res = sqlx::raw_sql(sql).execute(pool)
        .await.map_err(|e| AppError::SqlxError(e, sql.to_string()))?;
    
    info!("{} duplicate non-default city name records deleted (same country, name)", res.rows_affected());

    Ok(())
}



